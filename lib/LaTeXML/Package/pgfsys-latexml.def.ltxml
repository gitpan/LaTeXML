# -*- CPERL -*-
# /=====================================================================\ #
# |  pgfsys latexml driver                                              | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Thanks to Silviu Vlad Oprea <s.oprea@jacobs-university.de>          | #
# | of the arXMLiv group for initial implementation                     | #
# |    http://arxmliv.kwarc.info/                                       | #
# | Released under the Gnu Public License                               | #
# | Released to the Public Domain                                       | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;
use LaTeXML::Util::Image;
use List::Util qw(min max);
#=====================================================================
# Utilities
sub addToCount {
  my ($reg, $value, $option) = @_;
  $option = 'local' if !$option;
  AssignValue($reg => (LookupValue($reg) || 0) + $value, $option);
  return; }

#====================================================================#
#= 0. Environment specific stuff ====================================#
#====================================================================#

DefPrimitive('\lxSVG@installcommands', sub {
    # Local definitions.
    Let(T_CS('\hbox'),   T_CS('\lxSVG@hbox'));
    Let(T_CS('\vbox'),   T_CS('\lxSVG@vbox'));
    Let(T_CS('\lower'),  T_CS('\lxSVG@lower'));
    Let(T_CS('\raise'),  T_CS('\lxSVG@raise'));
    Let(T_CS('\hskip'),  T_CS('\lxSVG@hskip'));
    Let(T_CS('\halign'), T_CS('\lxSVG@halign'));
    AssignValue(TEXT_MODE_BINDINGS => []);
    return; });

# Redefine to disappear from UnTeX, since it appears a zillion times...
DefPrimitive('\lx@inpgf@ignorespaces SkipSpaces', sub { (); });
# Order might matter here
DefMacro('\lxSVG@picture', sub {
    Let('\ignorespaces', '\lx@inpgf@ignorespaces');    # Use local defn
    AssignValue('pgf_SVGpath' => '');
    (T_CS('\begingroup'), T_CS('\lxSVG@installcommands')); });

DefMacro('\endlxSVG@picture', '\endgroup');

DefConstructor('\lxSVG@pgfsys@insertpicture{}',
  '<ltx:picture>' .
    '<svg:svg version="1.1" width="#pxwidth" height="#pxheight" '
    . 'viewBox="#minx #miny #pxwidth #pxheight">'
    . '<svg:g transform="matrix(1 0 0 -1 0 #flipnmove)">'
    . '#1'
    . '</svg:g>'
    . '</svg:svg>'
    . '</ltx:picture>',
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $margin  = Dimension('2pt');
    my $margin2 = Dimension('4pt');
    # \pgf@picmaxx,\pgf@pixmaxy are now the SIZE of the picture!!!!!!
    my $minx   = LookupValue('\pgf@picminx')->subtract($margin);
    my $miny   = LookupValue('\pgf@picminy')->subtract($margin);
    my $width  = LookupValue('\pgf@picmaxx')->add($margin2);
    my $height = LookupValue('\pgf@picmaxy')->add($margin2);
    my $w      = max($width->pxValue, 1);
    my $h      = max($height->pxValue, 1);
    # Note viewbox is minx, miny, width, height (NOT maxx,maxy!)
    $whatsit->setProperty(minx      => $minx->pxValue);
    $whatsit->setProperty(miny      => $miny->pxValue);
    $whatsit->setProperty(width     => $width);
    $whatsit->setProperty(height    => $height);
    $whatsit->setProperty(depth     => Dimension(0));
    $whatsit->setProperty(pxwidth   => $w);
    $whatsit->setProperty(pxheight  => $h);
    $whatsit->setProperty(flipnmove => $h + 2 * $miny->pxValue);
    # or tikz macro (see corescopes)
    return; });

DefParameterType('SVGMoveableBox', sub {
    my ($gullet) = @_;
    $gullet->skipSpaces;
    my ($box, @stuff) = $STATE->getStomach->invokeToken($gullet->readXToken(1));
    Error(":expected:<box>  A <svghbox> was supposed to be here, got "
        . Stringify($box))
      unless $box && $box->isa('LaTeXML::Core::Whatsit')
      && ($box->getDefinition->getCSName =~ /^(\\lxSVG\@hbox||)$/);
    $box; });

# Check whether a svg:foreignObject is open,
# but don't check beyond an svg:svg node, in case we're nested.
sub foreignObjectCheck {
  my ($doc) = @_;
  my $node = $doc->getNode;
  while ($node) {
    my $n = $doc->getNodeQName($node);
    return if $n eq 'svg:svg';
    return $node if $n eq 'svg:foreignObject';
    $node = $node->parentNode; }
  return; }

DefConstructor('\lxSVG@raise Dimension SVGMoveableBox', sub {
    my ($doc, $dim, $box) = @_;
    if (foreignObjectCheck($doc)) {
      $doc->openElement('ltx:text',
        yoffset      => $dim->multiply(-1)->pxValue . 'px',
        _noautoclose => '1');
      $doc->absorb($box);
      $doc->closeElement('ltx:text'); }
    else { $doc->absorb($box); } },
  alias => '\raise');

DefConstructor('\lxSVG@lower Dimension SVGMoveableBox', sub {
    my ($doc, $dim, $box) = @_;
    if (foreignObjectCheck($doc)) {
      $doc->openElement('ltx:text',
        yoffset      => $dim->pxValue . 'px',
        _noautoclose => '1');
      $doc->absorb($box);
      $doc->closeElement('ltx:text'); }
    else { $doc->absorb($box); } },
  alias => '\lower');

DefConstructor('\lxSVG@hskip Glue', sub {
    my ($doc, $skip) = @_;
    if (foreignObjectCheck($doc)) {
      $doc->openElement('ltx:text',
        'xoffset'      => $skip->pxValue . 'px',
        '_noautoclose' => '0'); } },
  alias => '\hskip');

# Like regular \hbox, \vbox, but we don't want any extra element around it.
DefConstructor('\lxSVG@hbox BoxSpecification HBoxContents', '#2',
  mode => 'text', bounded => 1,
  # Workaround for $ in alignment; an explicit \hbox gives us a normal $.
  # And also things like \centerline that will end up bumping up to block level!
  sizer        => '#2',
  alias        => '\hbox',
  beforeDigest => sub { reenterTextMode(); },
  afterDigest  => sub {
    my ($stomach, $whatsit) = @_;
    my $spec = $whatsit->getArg(1);
    my $box  = $whatsit->getArg(2);
    if (my $w = GetKeyVal($spec, 'to')) {
      $whatsit->setWidth($w); }
    elsif (my $s = GetKeyVal($spec, 'spread')) {
      $whatsit->setWidth($box->getWidth->add($s)); }
    return; });

DefConstructor('\lxSVG@vbox BoxSpecification VBoxContents', '#2',
  sizer       => '#2',
  alias       => '\vbox',
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $spec = $whatsit->getArg(1);
    my $box  = $whatsit->getArg(2);
    if (my $h = GetKeyVal($spec, 'to')) {
      $whatsit->setHeight($h); }
    elsif (my $s = GetKeyVal($spec, 'spread')) {
      $whatsit->setHeight($box->getHeight->add($s)); }
    return; },
  mode => 'text');

#=====================================================================#
# 1. Beginning and ending a stream ===================================#
#=====================================================================#
DefMacro('\pgfsys@typesetpicturebox{}', <<'EoTeX');
% \pgf@picmaxx,\pgf@pixmaxy are now the SIZE of the picture!!!!!!
\advance\pgf@picmaxy by-\pgf@picminy\relax%
   \advance\pgf@picmaxx by-\pgf@picminx\relax%
   \ht#1=\pgf@picmaxy%
   \wd#1=\pgf@picmaxx%
   \dp#1=0pt%
   \leavevmode%\message{width: \the\pgf@picmaxx, height:\the\pgf@picmaxy}%%
   \lxSVG@pgfsys@insertpicture{\box#1}%
EoTeX

DefMacro('\pgfsys@beginpicture', '');
DefMacro('\pgfsys@endpicture',   '');

# Note that this is overly generous with svg:foreignObject.
# It is used to recursively contain svg:svg elements
# also simple strings end up there (they _could_ have exotic latexml attributes...)
DefConstructor('\lxSVG@pgfsys@foreignObject{Dimension}{Dimension}{Dimension}{}', sub {
    my ($doc, $w, $h, $d, $box, %prop) = @_;
    $doc->openElement('svg:g',
      # transform => 'matrix(1 0 0 -1 0 ' . $h->add($d)->pxValue . ')',
      # Sometimes, this SEEMS it would be the more correct vertical translation (w/o the depth!)??
      # but maybe that's just the bad size info we have?
      transform => 'matrix(1 0 0 -1 0 ' . $h->pxValue . ')',
      class     => 'ltx_svg_fog');
    my $strokeattr = $doc->findnode('ancestor-or-self::*/@stroke', $doc->getElement);
    my $sw = $doc->openElement('svg:switch');
    my ($ww, $hh, $dd) = $box->getSize;
    my $fo = $doc->openElement('svg:foreignObject',
      width    => $w->pxValue,
      height   => $h->add($d)->pxValue,
      overflow => 'visible',
      color    => $strokeattr && $strokeattr->getValue);
    my $p = $doc->openElement('ltx:p');
    $doc->absorb($box);
    $doc->maybeCloseElement('ltx:text');
    # $doc->closeElement('ltx:p');
    # $doc->closeElement('svg:foreignObject');
    # $doc->closeElement('svg:switch');
    # $doc->closeElement('svg:g');
    # If the nodes we just created are still there & open (see halign)
    # then close them now.
    $doc->maybeCloseElement('ltx:p');
    if (my $n = $doc->isCloseable('svg:foreignObject')) {
      if ($n->isSameNode($fo)) {
        $doc->closeElement('svg:foreignObject');
        $doc->closeElement('svg:switch');
        $doc->closeElement('svg:g');
        # Check the children of the inserted ltx:p
        # We should at least try to denest svg ?
        # If svg:switch/svg:foreignObject/ltx:p/ltx:picture/svg:svg/svg:g
        # should be replaced by just the final svg:g !!! (?)
        my @ch = element_nodes($p);
        if ((scalar(@ch) == 1) && ($doc->getNodeQName($ch[0]) eq 'ltx:picture')) {
          my @gch = element_nodes($ch[0]);
          if ((scalar(@gch) == 1) && ($doc->getNodeQName($gch[0]) eq 'svg:svg')) {
            my ($g) = element_nodes($gch[0]);
            $doc->replaceNode($sw, $g);
          } } } }
    # Could conceivably be simplifying ltx:text ???
  },
);

# this puts an \hbox into the picture,
# but it should set wd,ht,dp to 0!!! ???
DefMacro('\pgfsys@hbox{Number}', sub {
    my $box   = 'box' . $_[1]->valueOf;
    my $stuff = LookupValue($box);
    return if !$stuff;
    my ($w, $h, $d) = $stuff->getSize();
    Invocation(T_CS('\lxSVG@pgfsys@foreignObject'), $w, $h, $d,
      Invocation(T_CS('\box'), $_[1])); });

# # Can we do it this way? More latexmly
# # We're going to have to come back and add the size, however,
# Tag('svg:switch',autoOpen=>1,autoClose=>1);
# Tag('svg:foreignObject',autoOpen=>1,autoClose=>1,
# ##  afterOpen=>sub {
# ##    $_[0]->openElement('ltx:p'); }, # inf recursion w/o this???
#   afterClose=>sub {
#     my($doc,$fo)=@_;
#     if(my $box = $doc->getNodeBox($fo)){
#       my($w,$h,$d)=$box->getSize;
#       $doc->setAttribute($fo, width=>$w->pxValue) if $w;
#       $doc->setAttribute($fo, height=>$h->pxValue) if $h; }}
# );

# DefMacro('\pgfsys@hbox{Number}', sub {
#   Invocation(T_CS('\box'), $_[1]); });

# DefMacro('\pgfsys@hbox{Number}', '\pgfsys@@hbox{\box #1}');
# DefConstructor('\pgfsys@@hbox{}', '<ltx:p>#1</ltx:p>');

#DefConstructor('\maybepicture', sub {
#  my ($doc) = @_;
#  if ($doc->isOpen('svg:foreignObject')) {
#    $doc->openElement('svg:svg');
#  return; }
#});
#RawTeX('\expandafter\def\expandafter\node\expandafter{\expandafter\maybepicture\node');
#====================================================================#
#= 2. Path construction =============================================#
#====================================================================#

#=====================================================================
# Helpers

# Adding an element to the current SVG path
sub addToSVGPath {
  my ($operation, @points) = @_;
  my $newPath = join(' ', $operation, map { $_->pxValue } @points);
  if (my $currentPath = LookupValue('pgf_SVGpath')) {
    AssignValue(pgf_SVGpath => $currentPath . ' ' . $newPath); }
  else {
    AssignValue(pgf_SVGpath => $newPath); }
  return; }

# Drawing a horizontal line of given dimension
DefPrimitive('\lxSVG@pgfsys@hline{Dimension}', sub {
    addToSVGPath('h', $_[1]); return; });

# Drawing a vertical line of given dimension
DefPrimitive('\lxSVG@pgfsys@vline{Dimension}', sub {
    addToSVGPath('v', $_[1]); return; });

#=====================================================================
# Implementation

# Start a path at a specific point (x,y) or to move the current point of the
# current path to (x,yp) without drawing anything upon stroking (the current
# path is 'interrupted'
DefPrimitive('\pgfsys@moveto{Dimension}{Dimension}', sub {
    addToSVGPath('M', @_[1 .. $#_]); return; });

# Continue the current path to (#1,#2) with a line.
DefMacro('\pgfsys@lineto{Dimension}{Dimension}', sub {
    addToSVGPath('L', @_[1 .. $#_]); return; });

# Continue the current path with a bezier curver to (#5,#6). The
# control points of the curve are at (#1,#2) and (#3,#4).
DefPrimitive('\pgfsys@curveto{Dimension}{Dimension}{Dimension}'
    . '{Dimension}{Dimension}{Dimension}', sub {
    addToSVGPath('C', @_[1 .. $#_]); return; });

# Append a rectangle to the current path whose lower left corner is at
# (#1,#2) and whose width/height is given by (#3,#4).
DefMacro('\pgfsys@rect{}{}{}{}', sub {
    my ($gullet, $x, $y, $hmove, $vmove) = @_;
    (Invocation('\pgfsys@moveto', $x, $y),
      Invocation('\lxSVG@pgfsys@hline', $hmove),
      Invocation('\lxSVG@pgfsys@vline', $vmove),
      Invocation('\lxSVG@pgfsys@hline', Dimension('-' . ToString($hmove))),
      T_CS('\pgfsys@closepath')); });

# Close the current path. This results in joining the current point of
# the path with the point specified by the last moveto
# operation.
DefMacro('\pgfsys@closepath', sub { addToSVGPath('Z'); return; });

#=====================================================================#
#= 3. Canvas transformation ==========================================#
#=====================================================================#

# Perform a concatenation of the low-level current transformation
# matrix with the matrix given by the values #1 to #6. The
# transformation matrix is a transformation on a homogeneous
# 2D-coordinate system.
DefMacro('\pgfsys@transformcm{}{}{}{}{}{}', sub {
    addToCount('pgf_gcount', 1, 'global');
    Invocation('\pgfsysprotocol@literal', Invocation('\pgfsys@transformcm@', @_[1 .. $#_])); });

DefConstructor('\pgfsys@transformcm@{Float}{Float}{Float}{Float}{Dimension}{Dimension}',
  '<svg:g transform="matrix(#c1 #c2 #c3 #c4 #x #y)">',
  properties => {
    c1 => sub { $_[1]->valueOf; },
    c2 => sub { $_[2]->valueOf; },
    c3 => sub { $_[3]->valueOf; },
    c4 => sub { $_[4]->valueOf; },
    x  => sub { $_[5]->pxValue; },
    y  => sub { $_[6]->pxValue; } });
##  beforeDigest => sub { addToCount('pgf_gcount', 1, 'global'); });

#=====================================================================#
#= 4. Stroking, filling, and clipping ================================#
#=====================================================================#

#======================================================================
DefMacro('\lxSVG@pgfsys@drawpath{}', sub {
    my ($gullet, $arg) = @_;
    if ((LookupValue('pgf_clipnext') || 0) == 0) {
      Invocation('\lxSVG@pgfsys@drawunclippedpath', $arg); }
    else {
      Invocation('\lxSVG@pgfsys@drawclippedpath', $arg); }
});

#----------------------------------------------------------------------

DefMacro('\lxSVG@pgfsys@drawunclippedpath{}', sub {
    my $svgpath = LookupValue('pgf_SVGpath') || '';
    AssignValue(pgf_SVGpath => '');
    Invocation('\pgfsysprotocol@literal',
      Invocation('\lxSVG@pgfsys@drawunclippedpath@', $svgpath, $_[1])); });

DefMacro('\lxSVG@pgfsys@drawclippedpath{}', sub {
    my $svgpath = LookupValue('pgf_SVGpath') || '';
    AssignValue(pgf_SVGpath  => '');
    AssignValue(pgf_clipnext => 0);
    addToCount('pgf_gcount',   1, 'global');
    addToCount('pgf_objcount', 1, 'global');
    Invocation('\pgfsysprotocol@literal',
      Invocation('\lxSVG@pgfsys@drawclippedpath@', $svgpath, $_[1])) });

#----------------------------------------------------------------------

DefConstructor('\lxSVG@pgfsys@drawunclippedpath@{}{}',
  # Seemingly can get called with no path, which is invalid
  '?#1(<svg:path d="#1" style="#2" />)()');

DefConstructor('\lxSVG@pgfsys@drawclippedpath@{}{}',
  '<svg:clipPath id="pgfcp#objcount">'
    . '<svg:path id="pgfpath#objcount" d="#1" />'
    . '</svg:clipPath>'
    . '<svg:use xlink:href="#pgfpath#objcount" style="#2" />'
    . '<svg:g clip-path="url(#pgfcp#objcount)">',
  properties => {
    objcount => sub { LookupValue('pgf_objcount'); },
    pgfcp    => '#pgfcp',
    pgfpath  => '#pgfpath' },
  #  beforeDigest=>sub { #return; });
  #    addToCount('pgf_objcount', 1, 'global') });
  #    addToCount('pgf_gcount', 1, 'global'); });
);

#======================================================================
DefPrimitive('\lxSVG@pgfsys@discardpathnoclip', sub {
    AssignValue(pgf_SVGpath => '');
    return; });

DefMacro('\lxSVG@pgfsys@discardpathclip', sub {
    my $svgpath = LookupValue('pgf_SVGpath') || '';
    AssignValue(pgf_SVGpath  => '');
    AssignValue(pgf_clipnext => 0);
    addToCount('pgf_gcount',   1, 'global');
    addToCount('pgf_objcount', 1, 'global');
    Invocation('\pgfsysprotocol@literal',
      Invocation('\lxSVG@pgfsys@discardpathclip@', $svgpath)); });

#----------------------------------------------------------------------

DefConstructor('\lxSVG@pgfsys@discardpathclip@{}',
  '<svg:clipPath id="pgfcp#objcount">'
    . '<svg:path d="#1" />'
    . '</svg:clipPath>'
    . '<svg:g clip-path="url(#pgfcp#objcount)">',
  properties => {
    objcount => sub { LookupValue('pgf_objcount'); },
    pgfcp => '#pgfcp' });

#======================================================================
# Implementation

DefMacro('\pgfsys@stroke',     '\lxSVG@pgfsys@drawpath{fill:none}');
DefMacro('\pgfsys@fill',       '\lxSVG@pgfsys@drawpath{stroke:none}');
DefMacro('\pgfsys@fillstroke', '\lxSVG@pgfsys@drawpath{}');

DefMacro('\pgfsys@clipnext', sub { AssignValue(pgf_clipnext => 1); });

DefMacro('\pgfsys@discardpath', sub {
    if ((LookupValue('pgf_clipnext') || 0) == 1) {
      return T_CS('\lxSVG@pgfsys@discardpathclip'); }
    else {
      return T_CS('\lxSVG@pgfsys@discardpathnoclip');
} });

#=====================================================================#
#= 5. Graphic state option ===========================================#
#=====================================================================#

#=====================================================================
# LL
# Open an <svg:g>, with some sort of options
# keeping track of how many have been opened.
DefMacro('\lxSVG@pgfsys@begingroup{}', sub {
    addToCount('pgf_gcount', 1, 'global');
    (T_CS('\pgfsysprotocol@literal'), T_BEGIN,
      T_CS('\lxSVG@pgfsys@begingroup@'), T_BEGIN, $_[1]->unlist, T_END, T_END); });

DefConstructor('\lxSVG@pgfsys@begingroup@ RequiredKeyVals',
  '<svg:g %&GetKeyVals(#1)>');

DefMacro('\lxSVG@pgfsys@endgroup', sub {
    addToCount('pgf_gcount', -1, 'global');
    Invocation('\pgfsysprotocol@literal',
      T_CS('\lxSVG@pgfsys@endgroup@')); });

DefConstructor('\lxSVG@pgfsys@endgroup@',
  '</svg:g>');

#=====================================================================
# Implementation

# these need to arrange for proper reversion!
DefMacro('\pgfsys@setlinewidth{}',  '\lxSVG@pgfsys@begingroup{stroke-width={#1}}');
DefMacro('\pgfsys@buttcap',         '\lxSVG@pgfsys@begingroup{stroke-linecap=butt}');
DefMacro('\pgfsys@roundcap',        '\lxSVG@pgfsys@begingroup{stroke-linecap=round}');
DefMacro('\pgfsys@rectcap',         '\lxSVG@pgfsys@begingroup{stroke-linecap=rect}');
DefMacro('\pgfsys@miterjoin',       '\lxSVG@pgfsys@begingroup{stroke-linejoin=miter}');
DefMacro('\pgfsys@setmiterlimit{}', '\lxSVG@pgfsys@begingroup{stroke-miterlimit={#1}}');
DefMacro('\pgfsys@roundjoin',       '\lxSVG@pgfsys@begingroup{stroke-linejoin=round}');
DefMacro('\pgfsys@beveljoin',       '\lxSVG@pgfsys@begingroup{stroke-linejoin=bevel}');

DefMacro('\pgfsys@setdash{}{}', '\lxSVG@pgfsys@begingroup{'
    . 'stroke-dasharray={\ifx.#1.none\else#1\fi},'
    . 'stroke-dashoffset={#2}}');
DefMacro('\pgfsys@eoruletrue',  '\lxSVG@pgfsys@begingroup{fill-rule=evenodd}');
DefMacro('\pgfsys@eorulefalse', '\lxSVG@pgfsys@begingroup{fill-rule=nonzero}');

#=====================================================================#
#= 6. Color ==========================================================#
#=====================================================================#

#=====================================================================
# Helpers

DefMacro('\lxSVG@pgfsys@setcolor{}{}', '\ifpgfpicture\lxSVG@pgfsys@begingroup{#1={#2}}\fi');

# Need to defer until after color/xcolor are loaded!
AtBeginDocument('\def\XC@mcolor{\pgfsetcolor{.}}');

#=====================================================================
# Implementation

DefMacro('\pgfsys@color@rgb{}{}{}', sub {
    my ($stomach, $r, $g, $b) = @_;
    (Invocation('\pgfsys@color@rgb@stroke', $r, $g, $b),
      Invocation('\pgfsys@color@rgb@fill', $r, $g, $b)); });

DefMacro('\pgfsys@color@rgb@stroke{}{}{}', sub {
    Invocation('\lxSVG@pgfsys@setcolor', 'stroke',
      Color('rgb', $_[1], $_[2], $_[3])->toHex); });
DefMacro('\pgfsys@color@rgb@fill{}{}{}', sub {
    Invocation('\lxSVG@pgfsys@setcolor', 'fill',
      Color('rgb', $_[1], $_[2], $_[3])->toHex); });
DefMacro('\pgfsys@color@cmyk@stroke{}{}{}{}', sub {
    Invocation('\lxSVG@pgfsys@setcolor', 'stroke',
      Color('cmyk', $_[1], $_[2], $_[3], $_[4])->toHex); });
DefMacro('\pgfsys@color@cmyk@fill{}{}{}{}', sub {
    Invocation('\lxSVG@pgfsys@setcolor', 'fill',
      Color('cmyk', $_[1], $_[2], $_[3], $_[4])->toHex); });
DefMacro('\pgfsys@color@cmy@stroke{}{}{}', sub {
    Invocation('\lxSVG@pgfsys@setcolor', 'stroke',
      Color('cmy', $_[1], $_[2], $_[3])->toHex); });
DefMacro('\pgfsys@color@cmy@fill{}{}{}', sub {
    Invocation('\lxSVG@pgfsys@setcolor', 'fill',
      Color('cmy', $_[1], $_[2], $_[3])->toHex); });
DefMacro('\pgfsys@color@gray@stroke{}', sub {
    Invocation('\lxSVG@pgfsys@setcolor', 'stroke',
      Color('gray', $_[1])->toHex); });
DefMacro('\pgfsys@color@gray@fill{}', sub {
    Invocation('\lxSVG@pgfsys@setcolor', 'fill',
      Color('gray', $_[1])->toHex); });
#====================================================================#
#= 7. Pattern =======================================================#
#====================================================================#

#=====================================================================
# SLL
DefConstructor('\lxSVG@pgfsys@coloredpattern@{}{Dimension}{Dimension}{}',
  '<svg:defs><svg:pattern ' .
    'id ="pgfpat#1" ' .
    'patternUnits="userSpaceOnUse" ' .
    'width="#x_step" height="#y_step">' .
    '#4' .
    '</svg:pattern></svg:defs>',
  properties => {
    x_step => sub { $_[2]->pxValue; },
    y_step => sub { $_[3]->pxValue; } });

DefConstructor('\lxSVG@pgfsys@uncoloredpattern@{}{Dimension}{Dimension}{}',
  '<svg:defs>' .
    '<svg:pattern '
    . 'id ="pgfpat#1" '
    . 'patternUnits="userSpaceOnUse" '
    . 'width="#x_step" height="#y_step">'
    . '<svg:symbol id="pgfsym#1">#4</svg:symbol>'
    . '</svg:pattern></svg:defs>',
  properties => {
    x_step => sub { $_[2]->pxValue; },
    y_step => sub { $_[3]->pxValue; } });

DefConstructor('\pgfsys@setpatternuncolored@{}{}{}{}',
  '<svg:defs><svg:pattern id="pgfupat#objcount" xlink:href="#pgfpat#1">'
    . '<svg:g stroke="#color" fill="#color">'
    . '<svg:use xlink:href="#pgfsym#1"/>'
    . '</svg:g>'
    . '</svg:pattern></svg:defs>'
    . '<svg:g fill="url(#pgfupat#objcount)">',
  properties => {
    pgfsym   => '#pgfsym',
    pgfpat   => '#pgfpat',
    pgfupat  => '#pgfupat',
    objcount => sub { LookupValue('pgf_objcount') || 0; },
    color    => sub { Color('rgb', $_[2], $_[3], $_[4]); } });

#=====================================================================
# LL

DefMacro('\lxSVG@pgfsys@coloredpattern{}{}{}{}', sub {
    Invocation('\pgfsysprotocol@literal',
      Invocation('\lxSVG@pgfsys@coloredpattern@', @_[1 .. $#_])); });

DefMacro('\lxSVG@pgfsys@uncoloredpattern{}{}{}{}', sub {
    Invocation('\pgfsysprotocol@literal',
      Invocation('\lxSVG@pgfsys@uncoloredpattern@', @_[1 .. $#_])); });

#=====================================================================
# Implementation

# \pgfsys@declarepattern{name}{x1}{y1}{x2}{y2}{x step}{y step}{code}{ﬂag}
DefMacro('\pgfsys@declarepattern{}'
    . '{Dimension}{Dimension}{Dimension}{Dimension}{Dimension}{Dimension}'
    . '{}{Number}', sub {
    my ($gullet, $name, $x1, $y1, $x2, $y2, $x_step, $y_step, $code, $flag) = @_;
    AssignValue('\pgf@xa' => $x1);     AssignValue('\pgf@ya' => $y1);
    AssignValue('\pgf@xb' => $x2);     AssignValue('\pgf@yb' => $y2);
    AssignValue('\pgf@xc' => $x_step); AssignValue('\pgf@yc' => $y_step);
    if ($flag->valueOf == 1) {
      return Invocation('\lxSVG@pgfsys@coloredpattern', $name, $x_step, $y_step, $code); }
    else {
      return Invocation('\lxSVG@pgfsys@uncoloredpattern', $name, $x_step, $y_step, $code); }
    return; });

DefMacro('\pgfsys@setpatternuncolored{}{}{}{}', sub {
    addToCount('pgf_gcount',   1, 'global');
    addToCount('pgf_objcount', 1, 'global');
    Invocation('\pgfsysprotocol@literal',
      Invocation('\pgfsys@setpatternuncolored@', @_[1 .. $#_])); });

DefMacro('\pgfsys@setpatterncolored{}',
  '\lxSVG@pgfsys@setcolor{fill}{url(\#pgfpat#1)}');

#====================================================================#
#= 8. Scoping =======================================================#
#====================================================================#

# Saves the current graphic state on a graphic state stack. All
# changes to the graphic state parameters mentioned for \pgfsys@stroke
# and \pgfsys@fill will be local to the current graphic state and will
# the old values will be restored after endscope is used.
DefPrimitive('\lxSVG@internal@savegcount', sub {
    AssignValue(pgf_gcount_save => LookupValue('pgf_gcount') || 0);
    AssignValue(pgf_gcount => 0, 'global');
});

DefPrimitive('\lxSVG@internal@restoregcount', sub {
    AssignValue(pgf_gcount => LookupValue('pgf_gcount_save') || 0, 'global');
});

DefMacro('\pgfsys@beginscope', sub {
    (T_CS('\lxSVG@internal@savegcount'), T_CS('\begingroup'),
      # Is this really needed? A <g> w/ no attributes??
      #     T_CS('\lxSVG@pgfsys@begingroup'), T_BEGIN, T_END
    );
});

DefMacro('\pgfsys@endscope', sub {
    my @toks = ();
    push(@toks, T_CS('\lxSVG@pgfsys@endgroup'))
      foreach (1 .. LookupValue('pgf_gcount'));
    (@toks, T_CS('\endgroup'), T_CS('\lxSVG@internal@restoregcount')); });

#=====================================================================#
#= 9. Image ==========================================================#
#=====================================================================#

#=====================================================================
# Helpers

RawTeX('\newbox\lxSVG@imgbox');
#=====================================================================
# Implementation

DefMacro('\pgfsys@defineimage',
  '\edef\pgf@image{\lxSVG@includegraphics{\pgf@imagewidth}{\pgf@imageheight}{\pgf@filename}}');

DefConstructor('\lxSVG@includegraphics{}{} Semiverbatim',
  "<ltx:graphics graphic='#graphic' candidates='#candidates' options='#options'/>",
  beforeConstruct => sub {
    my ($document, $whatsit) = @_;
    if (!foreignObjectCheck($document)) {
      $document->openElement('svg:foreignObject',
        width => $whatsit->getWidth, height => $whatsit->getHeight);
      $whatsit->setProperty(OpenedForeignObject => 1); } },
  afterConstruct => sub {
    my ($document, $whatsit) = @_;
    if ($whatsit->getProperty('OpenedForeignObject')) {
      $document->closeElement('svg:foreignObject'); } },
  sizer      => \&image_graphicx_sizer,
  properties => sub {
    my ($stomach, $w, $h, $graphic) = @_;
    $w = ToString($w);
    $h = ToString($h);
    my $options = join(',', ($w ? ('width=' . $w) : ()), ($h ? ('height=' . $h) : ()));
    $graphic = ToString($graphic); $graphic =~ s/^\s+//; $graphic =~ s/\s+$//;
    my @candidates = pathname_findall($graphic, types => ['*'],
      paths => LookupValue('GRAPHICSPATHS'));
    if (my $base = LookupValue('SOURCEDIRECTORY')) {
      @candidates = map { pathname_relative($_, $base) } @candidates; }
    (graphic => $graphic,
      candidates => join(',', @candidates),
      options => $options); },
  alias => '\includegraphics');

#=====================================================================#
#= 10. Shading =======================================================#
#=====================================================================#

#=====================================================================
# Helpers

DefMacro('\lxSVG@pgfsys@sh@create', sub {
    (T_CS('\lxSVG@pgfsys@sh@intervals'), Expand(T_CS('\pgf@sys@shading@ranges')),
      T_BEGIN,
      T_BEGIN, T_CS('\pgf@sys@shading@end@pos'), T_END,
      T_BEGIN, T_CS('\pgf@sys@shading@end@pos'), T_END,
      T_BEGIN, T_CS('\pgf@sys@shading@end@rgb'), T_END,
      T_BEGIN, T_CS('\pgf@sys@shading@end@rgb'), T_END,
      T_END, T_BEGIN, T_END); });

DefPrimitive('\lxSVG@pgfsys@sh@color{Float}{Float}{Float}', sub {
    AssignValue(pgf_sh_color => Color('rgb', map { $_->valueOf } @_[1 .. $#_]));
    return; });

DefMacro('\lxSVG@pgfsys@sh@interval@{}',
  '\lxSVG@pgfsys@sh@stashstop{\lxSVG@pgfsys@sh@stop{#1}{\pgf@sys@shading@end@pos}}');
DefPrimitive('\lxSVG@pgfsys@sh@stashstop{}', sub {
    PushValue('pgf_sh_stops' => Digest($_[1]));
    return; });

DefConstructor('\lxSVG@pgfsys@sh@stop{Dimension}{Dimension}',
  "<svg:stop offset='#offset' stop-color='#stopcolor'/>",
  properties => sub {
    my ($r, $g, $b) = LookupValue('pgf_sh_color')->rgb->components;
    (offset => $_[1]->pxValue / $_[2]->pxValue,
      stopcolor => LookupValue('pgf_sh_color')); });

DefMacro('\lxSVG@pgfsys@sh@interval{}{}{}{}', sub {
    (T_CS('\lxSVG@pgfsys@sh@color'), $_[3],
      Invocation(T_CS('\lxSVG@pgfsys@sh@interval@'), $_[1])); });

DefMacro('\lxSVG@pgfsys@sh@intervals{}', sub {
    my ($gullet, $point) = @_;
    $point = Expand($point);
    return if !ToString($point);
    (T_CS('\lxSVG@pgfsys@sh@interval'), $point,
      T_CS('\lxSVG@pgfsys@sh@intervals')); });

# These should avoid creating so many constructors at run time
DefPrimitive('\lxSVG@pgfsys@sh@defstripes{}{Number}', sub {
    my ($stomach, $name, $flag) = @_;
    my $stops = List(@{ LookupValue('pgf_sh_stops') });
    AssignValue(pgf_sh_stops => []);
    my $x = LookupValue('\pgf@x')->pxValue;
    my $y = LookupValue('\pgf@y')->pxValue;

    DefPrimitiveI('\@pgfshading' . $name->ToString . '!', undef, sub {
        my $objcount = (LookupValue('pgf_objcount') || 0) + 1;
        AssignValue(pgf_objcount => $objcount, 'global');
        DefConstructor('\lxSVG@pgfsys@sh@defs',
          '<svg:defs><svg:linearGradient id="pgfsh' . $objcount . '" '
            . ($flag->valueOf == 1 ? 'gradientTransform="rotate(90)"' : '') . '>'
            . '#stops'
            . '</svg:linearGradient></svg:defs>',
          properties => { stops => $stops }
        );
        DefConstructor('\lxSVG@pgfsys@sh',
          '<svg:rect width="' . $x . '" height="' . $y . '" '
            . 'style="fill:url(#pgfsh);stroke:none" />',
          properties => { pgfsh => '#pgfsh' . $objcount });
        DefMacro('\lxSVG@pgfsys@pos', sub { Invocation(T_CS('\pgfpoint'), $x, $y); });
        return; }, scope => 'global');
    return; });

DefPrimitive('\lxSVG@pgfsys@sh@defcircles{}', sub {
    my ($stomach, $name) = @_;
    my $stops = List(@{ LookupValue('pgf_sh_stops') });
    AssignValue(pgf_sh_stops => []);
    my $endpos = Dimension(ToString Expand T_CS '\pgf@sys@shading@end@pos')->pxValue;
    my $x      = LookupValue('\pgf@x')->pxValue * 8 / ($endpos * 16) + 0.5;
    my $y      = LookupValue('\pgf@y')->pxValue * 8 / ($endpos * 16) + 0.5;
    DefPrimitiveI('\@pgfshading' . $name->ToString . '!', undef, sub {
        my $objcount = (LookupValue('pgf_objcount') || 0) + 1;
        AssignValue(pgf_objcount => $objcount, 'global');
        DefConstructor('\lxSVG@pgfsys@sh@defs',
          '<svg:defs><svg:radialGradient id="pgfsh' . $objcount . '" '
            . 'fx="' . $x . '" fy="' . $y . '">'
            . '#stops'
            . '</svg:radialGradient></svg:defs>',
          properties => { stops => $stops }
        );
        DefConstructor('\lxSVG@pgfsys@sh',
          '<svg:circle cx="' . $endpos . '" cy="' . $endpos . '" r="' . $endpos . '" '
            . 'style="fill:url(#pgfsh);stroke:none" />',
          properties => { pgfsh => '#pgfsh' . $objcount });
        DefMacro('\lxSVG@pgfsys@pos', sub {
            Invocation(T_CS('\pgfpoint'), 2 * $endpos, 2 * $endpos) });
        return; }, scope => 'global');
    return; });

DefConstructor('\lxSVG@pgfsys@sh@insert{Dimension}{Dimension}{}',
  '<svg:g transform="translate(#x #y)">#3</svg:g>',
  properties => {
    #    x => sub { $_[1]->pxValue; },
    #    y => sub { $_[2]->pxValue; } });
#### What's going on here? Why pt's instead of px ? (what are units?)
### (with px shading's way off)
    x => sub { $_[1]->ptValue; },
    y => sub { $_[2]->ptValue; } });

# \lxSVG@process{Dimension}{Dimension}
DefMacro('\lxSVG@process{}{}',
  '\ifdim\pgf@picmaxx<#1\global\pgf@picmaxx=#1\fi'
    . '\ifdim\pgf@picmaxy<#2\global\pgf@picmaxy=#2\fi'
    . '\ifdim\pgf@picminx>#1\global\pgf@picminx=#1\fi'
    . '\ifdim\pgf@picminy>#2\global\pgf@picminy=#2\fi');

#=====================================================================
# Implementation

DefMacro('\pgfsys@shadinginsidepgfpicture{}', <<'EoTeX');
%\message{Using shading \string#1}
 #1\lxSVG@pgfsys@sh@defs%
  \pgf@process{\lxSVG@pgfsys@pos}%
  \pgf@x=-.5\pgf@x\relax\pgf@y=-.5\pgf@y\relax%
%  \lxSVG@process{\pgf@x}{\pgf@y}%
%  \pgf@x=-1\pgf@x\relax\pgf@y=-1\pgf@y\relax%
%  \lxSVG@process{\pgf@x}{\pgf@y}%
  \lxSVG@pgfsys@sh@insert{\pgf@x}{\pgf@y}{\lxSVG@pgfsys@sh}
EoTeX

DefMacro('\pgfsys@shadingoutsidepgfpicture{}', <<'EoTeX');
\begingroup\lxSVG@installcommands%
  #1%
  \setbox\pgfpic=\hbox to0pt{%
      \lxSVG@pgfsys@sh@defs%
      \lxSVG@pgfsys@sh%
    }%
    \pgf@process{\lxSVG@pgfsys@pos}%
    \pgf@picminx=0pt%
    \pgf@picminy=0pt%
    \pgf@picmaxx=\pgf@x%
    \pgf@picmaxy=\pgf@y%
    \pgfsys@typesetpicturebox{\pgfpic}%
  \endgroup
EoTeX

# \pgfsys@horishading{}{Dimension}{}
DefMacro('\pgfsys@horishading{}{}{}', sub {
    my ($gullet, $name, $height, $specs) = @_;
    (Invocation(T_CS('\pgf@parsefunc'), $specs),
      T_CS('\lxSVG@pgfsys@sh@create'),
      Invocation(T_CS('\pgf@process'), Invocation(T_CS('\pgfpoint'),
          T_CS('\pgf@sys@shading@end@pos'), $height)),
      Invocation(T_CS('\lxSVG@pgfsys@sh@defstripes'),
        $name, Number(0))); });

## \pgfsys@vertshading{}{Dimension}{}
DefMacro('\pgfsys@vertshading{}{}{}', sub {
    my ($gullet, $name, $height, $specs) = @_;
    (Invocation(T_CS('\pgf@parsefunc'), $specs),
      T_CS('\lxSVG@pgfsys@sh@create'),
      Invocation(T_CS('\pgf@process'), Invocation(T_CS('\pgfpoint'),
          T_CS('\pgf@sys@shading@end@pos'), $height)),
      Invocation(T_CS('\lxSVG@pgfsys@sh@defstripes'), $name, Number(1))); });

DefMacro('\pgfsys@radialshading{}{}{}', sub {
    my ($gullet, $name, $point, $specs) = @_;
    (Invocation(T_CS('\pgf@parsefunc'), $specs),
      T_CS('\lxSVG@pgfsys@sh@create'),
      Invocation(T_CS('\pgf@process'),                $point),
      Invocation(T_CS('\lxSVG@pgfsys@sh@defcircles'), $name)); });

# Wow... postscript function...
DefMacro('\pgfsys@functionalshading{}{}{}', sub {
    my ($gullet, $name, $ll, $ur, $psfct) = @_;
    Let(T_CS('\lxSVG@pgfsys@sh@defs'), T_CS('\relax'));
    Let(T_CS('\lxSVG@pgfsys@sh'),      T_CS('\relax'));
    Let(T_CS('\lxSVG@pgfsys@pos'),     T_CS('\relax')); });

#=====================================================================#
#= 11. Transparency ==================================================#
#=====================================================================#

DefMacro('\pgfsys@stroke@opacity{}',           '\lxSVG@pgfsys@begingroup{stroke-opacity={#1}}');
DefMacro('\pgfsys@fill@opacity{}',             '\lxSVG@pgfsys@begingroup{fill-opacity={#1}}');
DefMacro('\pgfsys@fadingfrombox{}{}',          '');
DefMacro('\pgfsys@usefading{}{}{}{}{}{}{}',    '');
DefMacro('\pgfsys@transparencygroupfrombox{}', '');
DefMacro('\pgfsys@definemask',                 '');

#=====================================================================#
#= 12. Reusable objects ==============================================#
#=====================================================================#

DefConstructor('\pgfsys@invoke{}', '#1');
DefMacro('\pgfsys@markposition{}', '');

#=====================================================================#
#= 13. Invisibility ==================================================#
#=====================================================================#

RawTeX('\def\pgfsys@begininvisible#1\pgfsys@endinvisible{}');    # well...

#=====================================================================#
#= 14. The protocol subsystem ========================================#
#=====================================================================#

# # Adds the literal text to the current protocol, after it has been
# # \edef-ed. This command will always protocol.
# DefPrimitive('\pgfsysprotocol@literalbuffered{}', sub {});

# # First calls \pgfsysprotocol@literalbuffered on literal text . Then,
# # if protocolling is currently switched off, the literal text is passed
# # on to pgfsys@invoke, which just inserts it into the document.
# DefMacro('\pgfsysprotocol@literal{}', '');

# # Stores the current protocol in macro name for later use.
# DefPrimitive('\pgfsysprotocol@getcurrentprotocol{}', sub {});

# # Sets the current protocol to macro name.
# DefMacro('\pgfsysprotocol@setcurrentprotocol{}', sub{});

# # Inserts the text stored in the current protocol into the file.
# DefMacro('\pgfsysprotocol@invokecurrentprotocol', sub{});

# # First inserts the current protocol, then sets the current protocol to
# # the empty string.
# DefMacro('\pgfsysprotocol@flushcurrentprotocol', sub{});

#=====================================================================#
#= 15. Overflowing ===================================================#
#=====================================================================#

#=====================================================================#
#= XX. Matrix ========================================================#
#=====================================================================#
# Here we're basically groping to figure out how to adapt
# LaTeXML's Alignment structures to the tikz code.
# Note that svg doesn't have a table/array structure.
#
# I guess we should just be putting <svg:g> in, but with appropriate class?
# For this to work, we'll have to come in after the fact, sum up things & specify cell sizes.
# Also, it seems that we've already ended up with a foreign object box?
#
# But there are still some major problems:
# On top of that, we're somehow getting out-of-sync with the
# bgroup/egroup & begingroup/endgroup pairs that tikz/pgf is adding
# and the ones embedded in our alignment machinery.
# I _THINK_ we're running afoul of when the last item of \matrix ends with \\ ???
#
# It also appears that in order to align the cells,
# tikz makes their width 0; unfortunately this makes them
# disappear in the svg (overflow=visible doesn't seem to help)

DefConstructor('\lxSVG@halign BoxSpecification',
  '#body',
  reversion => '\halign #1{#2\cr#3}',
  #  bounded     => 1,
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $gullet = $stomach->getGullet;
    my $t      = $gullet->readNonSpace;
    Error('expected', '\bgroup', $stomach, "Missing \\halign box") unless Equals($t, T_BEGIN);
    print STDERR "\nHALIGN IN PGF!\n";
    # Read the template up till something equivalent to \cr
    my @template = ();
    # Only expand certain things; See TeX book p.238
    while (($t = $gullet->readToken(0)) && !Equals($t, T_CS('\cr'))) {
      if ($t->equals(T_CS('\tabskip'))) {    # Read the tabskip assignment
        $gullet->readKeyword('=');
        my $value = $gullet->readGlue; }     # Discard! In principle, should store in template!
      elsif ($t->equals(T_CS('\span'))) {    # ex-span-ded next token.
        $gullet->unread($gullet->readXToken(0)); }
      else {
        push(@template, $t); } }
    # Convert the template
    my $ismath  = $STATE->lookupValue('IN_MATH');
    my $before  = 1;                                # true if we're before a # in current column
    my @pre     = ();
    my @post    = ();
    my @cols    = ();
    my @nonreps = ();
    foreach my $t (@template, T_ALIGN) {            # put & at end, to save column!

      if ($t->equals(T_PARAM)) {
        $before = 0; }
      elsif ($t->equals(T_ALIGN)) {
        if ($before) { @nonreps = @cols; @cols = (); } # A & while we're before a column means Repeated columns
        else {                                         # Finished column spec; add it
              # Try some magic for math, so we can create a valid math matrix (maybe!)
              # DAMN \halign can't be in math, anyway.
              # So, to get a matrix, we'll have to rewrite the alignment!
          if ($ismath) {
            push(@pre, T_MATH); unshift(@post, T_MATH); }
          push(@cols, { before => Tokens(stripDupMath(beforeCellUnlist(Tokens(@pre)))),
              after => Tokens(stripDupMath(afterCellUnlist(Tokens(@post)))) });
          @pre = @post = (); $before = 1; } }
      elsif ($before) {
        push(@pre, $t) if @pre || !$t->equals(T_SPACE); }
      else {
        push(@post, $t) if @post || !$t->equals(T_SPACE); } }

    my $template = LaTeXML::Core::Alignment::Template->new((@nonreps ?
          (columns => [@nonreps], repeated => [@cols])
        : (columns => [@cols])));
    #  print STDERR "Template = ".Stringify(Tokens(@template))."\n => ".$template->show."\n";
    # Now read & digest the body.
    # Note that the body MUST end with a \cr, and that we've made Special Arrangments
    # with \alignment@cr to recognize the end of the \halign
    # and sneak a \@finish@alignment in!!!!!
    # (otherwise none of the row/column/alignment constructors know when to end, as written)
    my $spec = $whatsit->getArg(1);
    tikzAlignmentBindings($template, undef,
      attributes => {
        width       => orNull(GetKeyVal($spec, 'to')),
        'pad-width' => orNull(GetKeyVal($spec, 'spread')) });
    $stomach->bgroup;    # This will be closed by the \halign's closing }
                         # but tikz is sticking in an extra \begingroup ????
                         #    $stomach->begingroup;
    $gullet->unread(T_CS('\@start@alignment'));
    $whatsit->setBody($stomach->digestNextBody, undef);    # extra undef as dummy "trailer"
  });

sub tikzAlignmentBindings {
  my ($template, $mode) = @_;
  $mode = LookupValue('MODE') unless $mode;
  #  my $ismath    = $mode =~ /math$/;
  #  my $container = ($ismath ? 'ltx:XMArray' : 'ltx:tabular');
  #  my $rowtype   = ($ismath ? 'ltx:XMRow' : 'ltx:tr');
  #  my $coltype   = ($ismath ? 'ltx:XMCell' : 'ltx:td');
  my $container = 'svg:g';
  my $rowtype   = 'svg:g';
  my $coltype   = 'svg:g';
  AssignValue(Alignment => LaTeXML::Core::Alignment->new(
      template       => $template,
      openContainer  => \&openTikzAlignment,
      closeContainer => sub { $_[0]->closeElement($container); },
      openRow        => \&openTikzAlignmentRow,
      closeRow       => sub { $_[0]->closeElement($rowtype); },
      openColumn     => \&openTikzAlignmentCol,
      closeColumn    => sub { $_[0]->closeElement($coltype); }));
  # These would MASK tikz own new bindings
  # BUT it only seems sensible that we'll want to get tikz to call OUR bindings at some level!
  Let(T_ALIGN,           '\lxSVG@alignment@align');
  Let("\\\\",            '\lxSVG@alignment@newline');
  Let('\tabularnewline', '\lxSVG@alignment@newline');
  Let('\cr',             '\@alignment@cr');
  Let('\crcr',           '\@alignment@cr');
  Let('\hline',          '\@alignment@hline');
  #  Let(T_MATH, ($ismath ? '\@dollar@in@mathmode' : '\@dollar@in@textmode'));
  Let('\@open@row',  '\default@open@row');
  Let('\@close@row', '\default@close@row');

  return; }

sub openTikzAlignment {
  my ($doc, %props) = @_;
  # If we've already got a foreignObject opened, close it.
  if (my $fo = foreignObjectCheck($doc)) {
    $doc->removeNode($fo);
    my $x;
    # SHOULD be wrapped in an svg:switch inside an svg:g; remove them both!
    if (($x = $doc->getNode) && ($doc->getNodeQName($x) eq 'svg:switch')) {
      $doc->removeNode($x); }
    if (($x = $doc->getNode) && ($doc->getNodeQName($x) eq 'svg:g')
      && (($x->getAttribute('class') || '') eq 'ltx_svg_fog')) {
      $doc->removeNode($x); } }
  #    $doc->closeNode($fo); }
  return $doc->openElement('svg:g', class => 'ltx_tikzmatrix', %props); }

sub openTikzAlignmentRow {
  my ($doc, %props) = @_;
  $props{class} = ($props{class} ? $props{class} . ' ' : '') . 'ltx_tikzmatrix_row';
  return $doc->openElement('svg:g', class => 'ltx_tikzmatrix', %props); }

sub openTikzAlignmentCol {
  my ($doc, %props) = @_;
  $props{class} = ($props{class} ? $props{class} . ' ' : '') . 'ltx_tikzmatrix_col';
  if (my $align = $props{align}) {
    delete $props{align};
    $props{class} .= ' ltx_align_' . $align; }
  return $doc->openElement('svg:g', class => 'ltx_tikzmatrix', %props); }

# These may need to sneak in tikz' code somewhere?
DefMacroI('\lxSVG@alignment@align', undef,
  '\@close@inner@column\@close@column'
    # nextcell will end up attached to inner@column@after
    #    . '\pgfmatrixnextcell'
    . '\@alignment@align@marker'
    . '\@open@column\@open@inner@column');

# \lxSVG@alignment@newline OptionalMatch:* [Dimension]
DefMacro('\lxSVG@alignment@newline OptionalMatch:* []',
  # almost works; except at the END of the \matrix !!!
  '\pgfmatrixendrow'
    . '\@close@inner@column\@close@column\@close@row'
    . '\@alignment@newline@marker'
    . '\@open@row\@open@column\@open@inner@column');
#    .'\pgfutil@ifnextchar\egroup{}{\@open@row\@open@column\@open@inner@column}');
#    .'\pgfutil@ifnextchar\egroup{\begingroup}{\@open@row\@open@column\@open@inner@column}');

#=====================================================================
# Dealing with quick commands

# Coordinates
# Let(T_CS('\pgfqpoint'),T_CS('\pgfpoint'));
# Let(T_CS('\pgfqpointxy'),T_CS('\pgfpointxy'));
# Let(T_CS('\pgfqpointxyz'),T_CS('\pgfpointxyz'));
# Let(T_CS('\pgfqpointscale'),T_CS('\pgfpointscale'));

# Path construction

1;
